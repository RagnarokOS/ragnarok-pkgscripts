#!/usr/bin/env perl

# $Ragnarok$
# 
# sysupdate: update Ragnarok base system.

use strict;
use warnings;
use IPC::System::Simple qw(runx);
use List::Compare;
use File::Copy;
use File::Temp qw(tempdir);
use File::chdir;
use FindBin;
use lib $FindBin::Bin;
use PkgScripts::Config qw($mirror $pubkey $pkg_dir $cached $update_dir);
use Getopt::Long;
Getopt::Long::Configure('pass_through');

my $tmpdir	= tempdir("sysupdate-XXXXXXXXXX", CLEANUP => 1);

# Convenience
sub msg {
	my $msg	= @_;

	print("$msg\n");
}

# Wrapper around runx.
sub runcmd {
	my ($cmd, @args)	= @_;

	eval {
		runx($cmd, @args);
	};
	if ($@) {
		print("Can't run $cmd: $@\n");
	}
}

# Check if updates are found.
sub checkupdate {
	my $index	= @_;

	open(my $f1, '<', $index) or die("Can't open new index: $!\n");
	open(my $f2, '<', "index.orig.txt") or die("Can't open index.txt: $!\n");

	my @orig = <$f1>;
	my @new = <$f2>;

	my $list = List::Compare->new(\@orig, \@new);
	my @intersection = $list->get_intersection;

	if (@intersection) {
		my @updates = $list->get_unique;
		return @updates;
	}
	close($f1) or die("Can't close new index: $!\n");
	close($f2) or die("Can't close index.txt: $!\n");
}

# Verify a file sig with signify(1)
sub verify_sig {
	my ($file) = @_;

	msg("Verifying $file\'s signature...");
	runcmd('/usr/bin/signify', "-C", "-p", "$pubkey", "-x", "SHA256.sig", "$file");
}

# Download file as the 'sysupdate' user.
sub download {
	my ($destdir, $file, $source) = @_;

	# Use lib/download script for the moment.
	runcmd('lib/download', "$destdir", "$file", "$source");
}

# List installed updates
sub list_updates {
	msg("Installed Updates:");
	open(my $fh, '<', "index.txt") or die("Can't open sysupdate file: $!\n");
	while (my $line = <$fh>) {
		print($line);
	}
	close($fh) or die("Can't close sysupdate file: $!\n");
}

# Download and verify archives
sub get_update {
	my @archives	= @_;

	msg("Downloading updates...");
	foreach my $archive (@archives) {
		download($tmpdir, $archive, $mirror);
		if (verify_sig($archive)) {
			move("$tmpdir/$archive", "$update_dir/$archive");
		}
	}
}

# Extract sysupdate archive
sub extract {
	my $archive	= @_;

	runcmd('/usr/bin/tar', "$update_dir/$archive", '-C', "$update_dir/");
}

# Use rsync to send packages to PKGDIR, then fix Packages file
sub sync_pkgs {
	my @dirs	= @_;
	my @sorted	= sort { $a cmp $b } @dirs;

	# TODO: move this to install_updates or anything more appropriate
	foreach my $updir (@sorted) {
		$updir =~ s/\.tar\.xz$//i;
		runcmd('/usr/bin/rsync', '-Klrv', "$updir/", "$pkg_dir/");
	}
	runcmd('/usr/bin/emaint', '-f', 'binhost');
}

# Install update(s) downloaded with -d/--download.
sub install_updates {
	my @updates	= @_;
	my @sorted	= sort { $a cmp $b } @updates;

	# Extract and sync separately
	foreach my $update (@sorted) {
		extract($update);
	}

	foreach my $dir (@sorted) {
		$dir =~ s/\.tar\.xz$//i; 
		sync_pkgs($dir);
	}
	
	# Do the update
	runcmd('/usr/bin/emerge', '-avuDU', '--with-bdeps=y', '--usepkg', '@world');

	# Remove dir created when tarball was extracted
	foreach my $dir (@sorted) {
		$dir =~ s/\.tar\.xz$//i; 
		unlink($dir) or die("Can't remove $dir: $!\n");
	}

	# Remove tarball if CACHE_UPDATES is false
	if (!$cached) {
		foreach my $tarball (@updates) {
			unlink($tarball) or die("Can't remove $tarball: $!\n");
		}
	}
	
}

# Should this be a subroutine? Perhaps not.
sub main {
	my @updates;
	my %opts;

	# Get opts and run
	GetOptions(\%opts,
		'download',
		'install',
		'list',
		'query',
	);

	# 'list' and 'install' don't require downloading the update index, so
	# they come first.
	if ($opts{'list'}) {
		list_updates();
		exit(0);
	} elsif ($opts{'install'}) {
		my $tmpindex = "$update_dir/index.txt.tmp";

		if (!checkupdate($tmpindex)) {
			print("No downloaded update archives found.\nDid you run: 'sysupdate -d' first?.\n");
			exit(0);
		} else {
			@updates = checkupdate($tmpindex);
		}
		install_updates(@updates);
		unlink($tmpindex) or die("Can't remove $tmpindex: $!\n");
		exit(0);
	}

	# Every other option requires downloading index.txt and checking if
	# updates are available, so do it before checking $opts.
	msg("Downloading update index...");
	download($tmpdir, 'index.txt', $mirror);

	# Exit early if no updates are found
	if (!checkupdate("$tmpdir/index.txt")) {
		msg("No updates found, exiting...");
		exit(0);
	} else {
		@updates = checkupdate("$tmpdir/index.txt");
	}

	if ($opts{'download'}) {
		get_update(@updates);
		move("$tmpdir/index.txt", "$update_dir/index.txt.tmp");
	} elsif ($opts{'query'}) {
		print(@updates);
	} else {
		install_updates(@updates);
	}
}
main
